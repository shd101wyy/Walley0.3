;; compiler.toy
;; compiler written in toy language

;; define opcodes
(def SET 0x0)
(def GET 0x1)

(def CONST 0x2)
(def CONST_INTEGER 0x2100)
(def CONST_FLOAT 0x2200)
(def CONST_STRING 0x2300)
(def CONST_NULL 0x2400)

(def MAKELAMBDA 0x3)
(def RETURN 0x4)
(def NEWFRAME 0x5)
(def PUSH_ARG 0x6)
(def CALL 0x7)
(def JMP 0x8)
(def TEST 0x9)


;; GLOBAL VARIABLES
;; used to save variable name
;; this might be changed in the future
(def VARIABLE_TABLE  
  #[
    ;; frame 0
    #["cons", "car", "cdr", "vector", "vector-ref", "vector-set!",
      "vector-length", "vector?", "+", "-", "*", "/", "=",
      "<", ">", "<=", ">=", "eq?", "string?", "int?",
      "float?", "pair?", "null?", 
      "string<?", "string=?", "string-ref", "string-slice", "string-length",
      "vector-slice", "acos", "acosh", "asin", "asinh", "atan", "atanh",
      "ceil", "cos", "cosh", "exp", "floor", "loge", "pow", "sin", "sinh",
      "tan", "tanh", "display-string", "->int", "->float", "int->string", "float->string",
      "string-append", "lambda?", "vector-push!", "vector-pop!", "object", "object?", "object-keys",
      "bitwise-and", "bitwise-or", "bitwise-<<", "bitwise->>", "bitwise-not", "bitwise-xor", 
      "string->char-code", "char-code->string", "int->string-16", "string->int", "string->float"
      ]
    ])
;; used to save macros
(def MACROS #[#[]]) 
(def BUILTIN_PRIMITIVE_PROCEDURE_NUM (vector-length (vector-ref VARIABLE_TABLE 0)))

;; var ENVIRONMENT is written in C/JavaScript Language

;; find variable in Variable Table
(def (vt-find vt var-name)
  (def vt-length (vector-length vt))
  (defn vt-find-iter [i]
    (if (= i vt-length)
      #[-1, -1]
      (let [index (vector-find (vector-ref vt i)
                               var-name)]
        (if (= -1 index)
          (vt-find-iter (+ i 1))
          #[i, index])
        )))
  (vt-find-iter 0)) 

;; 4-digits-hex
(def (4-digits-hex num)
  (def s (int->string-16 num))
  (def l (string-length s))
  (def (zeros-ahead-str num s)
    (if (= num 0)
      s
      (zeros-ahead-str (- num 1)
                       (string-append s "0"))))
  (cond [(< l 4) ;; put 0 ahead
         (string-append (zeros-ahead-str (- 4 l) "")
                        s)]
        [else 
         s]))
;; printInstructions
(def (printInstructions insts)
  (def num 1)
  (def out-str "")
  (def insts-length (vector-length insts))
  (def (% n0 n1) (let! [result (->int (/ n0 n1))]  (- n0 (* result n1))))
  (def (helper i) ;; so ugly...
    (if (= i insts-length)
      (display out-str) ;; done
      (begin (set! out-str (string-append out-str
                                          (4-digits-hex (vector-ref insts i))
                                          " "))
             (if (= (% num 4)
                    0)
               (begin (display out-str)
                      (set! out-str "")
                      (++ num)
                      (helper (+ i 1)))
               (begin (++ num)
                      (helper (+ i 1)))))
      ))
  (helper 0))

;; check string is Integer
(def (isInteger n)
  (def l (string-length n))
  (if (= l 0)
    '()
    (begin (set! n (if (string=? (string-ref n 0)
                                 "-")
                     (string-slice 1 l)
                     n))
           (or (string=? n "0")     ;; 0
               (string-is-digit n)) ;; hexa or decimal 
           )
    ))
;; check string is float
(def (isFloat n)
  (def index-of-dot (string-find n "."))
  (if (= index-of-dot -1)
    '()  ;; not float
    (let! [a (string-slice n 
                           0
                           index-of-dot)
           b (string-slice n
                           (+ index-of-dot 1)
                           (string-length n))]
          (and (isInteger a)
               (isInteger b)))))
;; MACROS ==========
;; #(macro-name macro-clauses macro-vt)
(defm get-macro-name [macro] (vector-ref ~macro 0))
(defm get-macro-clauses [macro] (vector-ref ~macro 1))
(defm get-macro-vt [macro] (vector-ref ~macro 2))

;; FUNCTION_FOR_COMPILATION =======
;; #(param-num variadic-place start-pc vt)
(defm get-compiled-function-param-num [f] (vector-ref ~f 0))
(defm get-compiled-function-variadic-place [f] (vector-ref ~f 1))
(defm get-compiled-function-start-pc [f] (vector-ref ~f 2))
(defm get-compiled-function-vt [f] (vector-ref ~f 3))

;; ###################################################
;; ERROR:
;;      1 不应该允许 def in if 。 例如 (if 1 (def x 2) (def y 3)) 是错误的
;; Compiler 
(def compiler ())
(def compiler-begin ())
;; begin to write compiler function
(def (compiler 
      l       ;;; input expression 
      vt      ;;; variable table
      insts   ;;; instructions
      macros  ;;; macros 
      function-for-compilation ;;; function-for-compilation
      tail-call-flag  ;;; used to check whether exp is tail call
      parent-func-name  ;;; current function name
      )
  ;(display l)
  ;(display vt)
  ;(display insts)
  ;(display macros)
  ;(display function-for-compilation)
  ;(display tail-call-flag)
  ;(display parent-func-name)

  (cond [(null? l) ;; null
         (vector-push! insts CONST_NULL)] ;; push null
        [(string? l) ;; num var .. null
         ;; check number
         (cond [(isInteger l) ;; integer
                (let [i (string->int l)]
                  (if (< i 0) ;; negative number
                    (compiler (list "-" "0" l)
                              vt
                              insts
                              macros
                              function-for-compilation
                              tail-call-flag
                              parent-func-name)
                    (begin ;(display i)
                     (if (> i 0x7FFFFFFF)
                       (begin ;(display 0xFFFFFFFF) 
                        (display "ERROR: Integer too big")
                        'ERROR)
                       (begin (vector-push! insts CONST_INTEGER) ;;;; TRY 32bits first
                              (vector-push! insts (bitwise->> (bitwise-and 0xFFFF0000
                                                                           i)
                                                              16))
                              (vector-push! insts (bitwise-and 0xFFFF
                                                               i))
                              ))
                     ))
                  )
                ]
               [(isFloat l)   ;; float
                (let [f (string->float l)]
                  (if (< f 0) ;; negative number
                    (compiler (list "-" 0 l)
                              vt
                              insts
                              macros
                              function-for-compilation
                              tail-call-flag
                              parent-func-name)
                    (begin 
                     (let [i (->int f)]   ;; positive number 
                       (if (> i 0xFFFF)
                         (begin (display "ERROR: Float too big")
                                'ERROR)
                         (begin (vector-push! insts CONST_FLOAT)
                                (vector-push! insts i) ;; int part
                                (vector-push! insts (->int (* (- f i) ;; decimal part
                                                              10000)))))))))
                ]
               [(string=? (string-ref l 0) ;; string
                          "\"")
                (let [s (eval-string-for-compilation l)
                      length (string-length s)
                      find-end false
                      compile-string (lambda [i] ;; return find-end
                                             (if (= i length)
                                               '() ;; didnt find end
                                               (if (= (+ i 1)
                                                      length)
                                                 (begin ;; find end 
                                                  (vector-push! insts (bitwise-and (bitwise-<< (string->char-code s i)
                                                                                               8)
                                                                                   0xFF00)
                                                                'true))
                                                 (begin ;; didnt find end 
                                                  (vector-push! insts (bitwise-or (bitwise-<< (string->char-code s i)
                                                                                              8)
                                                                                  (string->char-code s (+ i 1))))
                                                  (compile-string  (+ i 2))))))]

                  (vector-push! insts CONST_STRING) ;; create string
                  (vector-push! insts (+ length 1)) ;; with length
                  (if (compile-string 0)
                    '() ;; find end already
                    (vector-push! insts 0x0000 ;; add end
                                  )))]
               [else          ;; variable
                (let [index (vt-find vt l)]
                  (if (= (vector-ref index 0)
                         -1)
                    (begin ;; didnt find 
                     (display (string-append "ERROR: undefined variables: " l))
                     'ERROR ;; error handler
                     )
                    (begin ;; find 
                     (vector-push! insts (bitwise-or (bitwise-<< GET 12)
                                                     (vector-ref index 0)))
                     (vector-push! insts (vector-ref index 1)))))
                ])]
        [(pair? l)
         (let [tag (car l)]
           (cond [(int? tag) '()]        ;; macro get 
                 [(string=? tag "quote") ;; quote
                  (let [v (car l)]
                    (cond [(pair? v)
                           (let [quote-list 
                                 (lambda [l] ;; function used to compile list
                                         (cond [(null? l)
                                                '()]
                                               [(pair? (car l)) ;; (() a) car is pair
                                                (list "cons" (quote-list (car l)) (quote-list (cdr l)))]
                                               [(eq? (car l) ".")
                                                (list "quote" (cadr l))]
                                               ;; (cons "quote" (cons (cadr l) '()))]
                                               [else 
                                                (list "cons" 
                                                      (list "quote" (car l))
                                                      (quote-list (cdr l)))])
                                         )]
                             (compiler (quote-list v) ;; compile formatted expression
                                       vt
                                       insts
                                       macros
                                       function-for-compilation
                                       tail-call-flag
                                       parent-func-name))
                           ] 
                          [(or (null? v)
                               (isInteger v)
                               (isFloat v)
                               (string=? (string-ref v 0)
                                         "\""))
                           ;; it is () int float or string. 
                           (compiler v
                                     vt
                                     insts
                                     macros
                                     function-for-compilation
                                     tail-call-flag
                                     parent-func-name)]
                          [else   ;; symbol/string 
                           (compiler (string-append "\"" v "\"")
                                     vt
                                     insts
                                     macros
                                     function-for-compilation
                                     tail-call-flag
                                     parent-func-name)]
                        ))
                  ]
                 [(string=? tag "quasiquote")  ;; quasiquote
                  (let [v (cadr l)]
                    (cond [(pair? v)  
                           (let [quasiquote
                                 (lambda [l]
                                         (cond [(null? l) '()] 
                                               [(pair? (car l))
                                                (cond [(eq? (caar l)
                                                            "unquote")
                                                       (list "cons" (cadr (car l)) (quasiquote (cdr l)))]
                                                      [(eq? (caar l)
                                                            "unquote-splice")
                                                       (list "append" (cadr (car l)) (quasiquote (cdr l)))]
                                                      [else 
                                                       (list "cons" (quasiquote (car l)) (quasiquote (cdr l)))])
                                                ]
                                               [(eq? (car l) ".")
                                                (list "quote" (cadr l))]
                                               [else 
                                                (list "cons"
                                                      (list "quote" (car l))
                                                      (quasiquote (cdr l)))]
                                               ))]
                             (compiler (quasiquote v)
                                       vt
                                       insts
                                       macros
                                       function-for-compilation
                                       tail-call-flag
                                       parent-func-name)
                             )]
                          
                          [(or (null? v)
                               (isInteger v)
                               (isFloat v)
                               (string=? (string-ref v 0)
                                         "\""))
                           ;; it is () int float or string. 
                           (compiler v
                                     vt
                                     insts
                                     macros
                                     function-for-compilation
                                     tail-call-flag
                                     parent-func-name)]
                          [else   ;; symbol/string 
                           (compiler (string-append "\"" v "\"")
                                     vt
                                     insts
                                     macros
                                     function-for-compilation
                                     tail-call-flag
                                     parent-func-name)]))
                  
                  ]
               ;;; ######### def #########################################
                 [(string=? tag "def")
                  (let [variable-name (cadr l)]
                    (if (pair? variable-name)
                      ;; (def (add a b) (+ a b))
                      (let [var-name (car variable-name)
                            args     (cdr variable-name)
                            lambda-body (cons "lambda" (cons args (cddr l)))]
                        (compiler (list "def" var-name lambda-body)
                                  vt
                                  insts
                                  macros
                                  function-for-compilation
                                  tail-call-flag
                                  parent-func-name))
                      ;; (def variable-name variable-value)                      
                      (let [variable-value (if (null? (cddr l)) '() (caddr l))
                            ;; check whether variable already defined
                            frame (vector-ref vt 
                                              (- (vector-length vt)
                                                 1))
                            frame-length (vector-length frame)
                            check-variable-existed-in-current-top-frame 
                            (lambda [i]
                                    (if (= i frame-length)
                                      (begin (vector-push! frame variable-name)
                                             frame-length)  ;; didn't find, so add to top frame
                                      (if (string=? (vector-ref frame i)
                                                    variable-name)
                                        ;; find variable-name
                                        i
                                        ;; didn't find, so continue
                                        (check-variable-existed-in-current-top-frame (+ i 1)))))
                            variable-index (check-variable-existed-in-current-top-frame 0) ;; search variable
                            ]
                        (compiler variable-value  ;; compile value
                                  vt
                                  insts
                                  macros
                                  function-for-compilation
                                  tail-call-flag
                                  (if (and (pair? variable-value)  ;; update parent-func-name if val is lambda
                                           (eq? "lambda" (car variable-value)))
                                    variable-name
                                    parent-func-name)
                                  )
                        ;; add instructions
                        (vector-push! insts (bitwise-or (bitwise-<< SET 12)
                                                        (- (vector-length vt)
                                                           1)))
                        (vector-push! insts variable-index))                         
                      ))]
               ;;; ################ set! ############################
                 [(string=? tag "set!")
                  (let [variable-name (cadr l)    ;; variable name
                        variable-value (caddr l)  ;; variable value
                        index (vt-find vt variable-name) ;; index of variable
                        ]  
                    (if (= (vector-ref index 0)
                           -1)
                      (begin ;; didnt find variable 
                       (display (string-append "ERROR: Undefined Variable: " variable-name))
                       'ERROR)
                      (begin
                       (compiler variable-value ;; compile value
                                 vt
                                 insts
                                 macros
                                 function-for-compilation
                                 tail-call-flag
                                 (if (and (pair? variable-value) ;; update parent-func-name
                                          (eq? (car variable-value) "lambda"))
                                   variable-name
                                   parent-func-name))
                       ;; add instructions
                       (vector-push! insts (bitwise-or (bitwise-<< SET 12)
                                                       (bitwise-and 0x0FFF (vector-ref index 0))))
                       (vector-push! insts (bitwise-and 0x0000FFFF
                                                        (vector-ref index 1)))
                       )))]
               ;;; ############ if ############
                 [(string=? tag "if")
                  (let [test (cadr l)
                        conseq (caddr l)
                        alter (if (null? (cdddr l)) '() (cadddr l))
                        ]
                    ;; compile test, which is not tail call
                    (compiler test
                              vt
                              insts
                              macros
                              function-for-compilation
                              '()
                              parent-func-name)
                    ;; jump over consequence
                    (vector-push! insts (bitwise-<< TEST 12))
                    ;; save index
                    (let [index1 (vector-length insts)
                          ]
                      ;; push test, but we dont know jump steps right now            
                      (vector-push! insts 0x0000) ;; jump-steps
                      ;; compile conseq
                      (compiler-begin (cons conseq '())
                                      vt
                                      insts
                                      macros
                                      function-for-compilation
                                      tail-call-flag
                                      parent-func-name)
                      (let [index2 (vector-length insts) ;; save index2
                            jump-steps (+ (- index2 index1) 4)]
                                              ;; push jump
                        (vector-push! insts (bitwise-<< JMP 12))
                        (vector-push! insts 0x0000) ;; save space for jump steps
                        (vector-push! insts 0x0000)
                        ;; set index1
                        (vector-set! insts index1 jump-steps)
                        
                        ;; compile alternative
                        (compiler-begin (cons alter '())
                                        vt
                                        insts
                                        macros
                                        function-for-compilation
                                        tail-call-flag
                                        parent-func-name)
                        (let [index3 (vector-length insts) ;; save index
                              jump-steps (- index3 index2)]
                          ;; set index2
                          (vector-set! insts
                                       (+ index2 1)
                                       (bitwise->> (bitwise-and 0xFFFF0000 jump-steps)
                                                   16))
                          (vector-set! insts
                                       (+ index2 2)
                                       (bitwise-and 0xFFFF jump-steps))
                          ))))
                   ]
                 ;; ############ begin ##############
                 [(string=? tag "begin")
                  (compiler-begin (cdr l)
                                  vt
                                  insts
                                  macros
                                  function-for-compilation
                                  tail-call-flag
                                  parent-func-name)]
                 ;; ############# lambda ############
                 ;; (lambda args . body)
                 [(string=? tag "lambda")
                  (let [params (cadr l)  ;; get parameters
                        variadic-place -1 ;; variadic-place
                        counter 0         ;; count of parameter num
                        vt_ (vector-slice vt 0 (vector-length vt)) ;; new variable table
                        macros_ (vector-slice macros 0 (vector-length macros)) ;; new macros
                        top-frame_ #['() '()]
                        count-parameters 
                        (lambda [params    ;; provided parameters
                                 counter   ;; counter for parameters, parameters num
                                 ]
                                (cond [(null? params)
                                       counter
                                       ]
                                      [(string=? (car params) ".") ;; variadic
                                       (begin (set! variadic-place counter) ;; set variadic-place
                                              (vector-push! top-frame_ (cadr params))  ;; push param
                                              (+ counter 1) ;; return counter
                                              )
                                       ]
                                      [else (begin (vector-push! top-frame_ (car params)) ;; push param
                                                   (count-parameters (cdr params)  ;; continue func
                                                                     (+ counter 1)))]
                                      ))
                        counter (count-parameters params 0)
                        ] 
          
                    
                    (vector-push! vt_ top-frame_)  ;; add new frame, and save space for parent-env and return-address
                    (vector-push! macros_ #[])  ;; add new frame
                    ;; make lambda
                    (vector-push! insts 
                                  (bitwise-or (bitwise-<< MAKELAMBDA 12) ;; op
                                              (bitwise-<< counter 6)     ;; #param
                                              (if (= variadic-place -1) 
                                                0x0000                   ;; variadic-place
                                                (bitwise-<< variadic-place 1))
                                              (if (= variadic-place -1)
                                                0x0000 ;; flag for variadic-place
                                                0x0001)))
                    (let [index1 (vector-length insts)] ;; save index1
                      (vector-push! insts 0x0000)  ;; steps that needed to jump over lambda
                      ;; for tail call optimization
                      (let [start-pc (vector-length insts) ;; get start-pc
                            ]
                        ;; compile body
                        (compiler-begin (cddr l)
                                        vt_
                                        insts
                                        macros_
                                        ;; function-for-compilation
                                        #(counter, variadic-place, start-pc, vt_)
                                        tail-call-flag
                                        parent-func-name)
                        ;; return
                        (vector-push! insts (bitwise-<< RETURN 12))
                        (vector-set! insts index1 (- (vector-length insts)
                                                     index1)) ;; set jump steps
                        ;; DONE
                        )))
                  ]
                 ;; ########### defmacro #################
                 [(string=? tag "defmacro")
                  (let [var-name (cadr l) ;; macro name
                        clauses (cddr l)  ;; clauses
                        top-macro-frame (vector-ref macros (- (vector-length macros) 1))
                        top-macro-frame-length (vector-length top-macro-frame)
                        check-macro-existed 
                        (lambda [i]
                                (if (= i top-macro-frame-length)
                                  ;; macro doesnt exist
                                  (vector-push! top-macro-frame #(var-name clauses (vector-slice vt (vector-length vt))))
                                  ;; check macro existed?
                                  (if (string=? var-name
                                                (get-macro-name (vector-ref top-macro-frame i))
                                                )
                                    (begin ;; already defined 
                                     (vector-set! top-macro-frame i clauses) ;; reset macro
                                     'true)
                                    (check-macro-existed (+ i 1)))) ;; continue function
                                )
                        ]
                    (check-macro-existed)
                    ;; 'Done
                    )]
                 [(string=? tag "macroexpand-1")
                  '()]
                 [(string=? tag "return")
                  (compiler (if (null? (cdr l))
                              '()
                              (cadr l))
                            vt
                            insts
                            macros
                            function-for-compilation
                            tail-call-flag
                            parent-func-name)
                  (vector-push! insts (bitwise-<< RETURN 12))]
                 ;; ####### CALL FUNCTION #####################
                 [else
                  (let [func (car l)
                        macros-length (vector-length macros)
                        check-macro-frame (lambda [frame i]
                                                  (if (= i (vector-length frame))
                                                    '() ;; didnt find macro in current frame
                                                    (if (eq? func (get-macro-name (vector-ref frame i)))
                                                      (vector-ref frame i) ;; find macro
                                                      (check-macro-frame frame (+ i 1)))))
                        check-macros (lambda [i]
                                         (if (= i macros-length)
                                           '()
                                           (let [v (check-macro-frame (vector-ref macros i) 0)]
                                             (if v
                                               v
                                               (check-macros (+ i 1))))))
                        is-macro (check-macros 0)]
                    (cond [is-macro ;; is macro, so expand it
                           (display "IT IS MACRO")]
                          
                          [tail-call-flag ;; tail call
                           (let [top-frame (vector-ref vt (- (vector-length vt) 1))
                                 start-index (vector-length top-frame)
                                 track-index start-index
                                 params (cdr l) 
                                 param-num (list-length params)
                                 count-params 0 ;; count param num
                                 ;; compile parameters
                                 required-function-param (get-compiled-function-param-num function-for-compilation)
                                 required-variadic-place (get-compiled-function-variadic-place function-for-compilation)
                                 required-start-pc (get-compiled-function-start-pc function-for-compilation)
                                 required-start-vt (get-compiled-function-vt function-for-compilation)
                                 ;; compile parameters
                                 ;; return count-params
                                 compile-parameters
                                 (lambda [params count-params track-index]
                                         (if (null? params)
                                           ;; no more params
                                           count-params
                                           (if (= count-params
                                                  required-variadic-place) ;; meet variadic place
                                             (begin 
                                              ;; compile params as list
                                              (compiler (cons "list" params)
                                                        vt
                                                        insts
                                                        macros
                                                        function-for-compilation
                                                        tail-call-flag
                                                       parent-func-name)
                                              ;; set to current frame
                                              (vector-push! insts (bitwise-or (bitwise-<< SET 12)
                                                                              (- (vector-length) 1)))
                                              (vector-push! insts track-index)
                                              (+ count-params 1))
                                             ;; is not variadic parameter
                                             (begin 
                                              ;; compile that param
                                              (compiler (car params)
                                                        vt
                                                        insts
                                                        macros
                                                        function-for-compilation
                                                        '() ;; it's not tail call
                                                        parent-func-name)
                                              ;; set to current frame
                                              (vector-push! insts (bitwise-or (bitwise-<< SET 12)
                                                                              (- (vector-length) 1)))
                                              (vector-push! insts track-index)
                                              ;; continue
                                              (compile-parameters params
                                                                  (+ count-params 1)
                                                                  (+ track-index))
                                              ))))
                                 ;; move-parameters
                                 ;; move compiled parameters up
                                 move-parameters
                                 (lambda [i]
                                         (if (= i count-params)
                                           '() ;; finish move
                                           (begin 
                                            ;; get parameter
                                            (vector-push! insts
                                                          (bitwise-or (bitwise-<< GET 12)
                                                                      (- (vector-length vt) 1)))
                                            (vector-push! insts (+ start-index i))
                                            
                                            ;; set parameter
                                            ;; move to target index
                                            (vector-push! insts 
                                                          (bitwise-or (bitwise-<< GET 12)
                                                                      (- (vector-length vt) 1)))
                                            )))
                                 ])]))
                  ]
                 )])
        [else
         (display "ERROR: compiler error")
         (display l)
         'ERROR ;; error handler
         ])
  )
;; Compiler Begin
(def (compiler-begin
      l       ;;; input expression
      vt      ;;; variable table
      insts   ;;; instructions
      macros  ;;; macros 
      function-for-compilation ;;; function-for-compilation 
      tail-call-flag ;;; used to check whether exp is tail call
      parent-func-name  ;;; current function name
      )			
  (if (null? l)
    'Done   ; finish compilation
    (if (and (not (null? parent-func-name)) 
             (null? (cdr l)) ;; last exp
             (pair? (car l)) ;; exp might be lambda
             (string=? (car (car l))  ;; has the same function name
                       parent-func-name)) 
      ;; tail call
      (begin (let! [result (compiler (car l)
                                     vt
                                     insts
                                     macros
                                     function-for-compilation
                                     'true     ;; tail call
                                     '())]
                   (if (eq? result 'ERROR)
                     (begin (display "EXP: ") (display (car l))) ;; get error
                     '()))
             'Done) ;; finish compilation
      ;; not tail call
      (begin
             (let [result (compiler (car l)
                                    vt
                                    insts
                                    macros
                                    function-for-compilation
                                    '()        ;; not tail call
                                    parent-func-name)]
               (if (eq? result 'ERROR)
                 (begin (display "EXP: ")
                        (display (car l))) ;; get error
                 (compiler-begin (cdr l)
                                 vt
                                 insts))
               )
             ))))


;; test
;; run compiler
(def x "(if 1 2 3)")
(def l (lexer x))
(def p (parser l))

(display "PARSER: ")
(display p)

(def INSTS #[])
(compiler-begin  p 
                 VARIABLE_TABLE
                 INSTS)
;(display (vector-length INSTS))
(display "*** FINISH COMPILATION ***")
(printInstructions INSTS)
(display "*** END ***")


