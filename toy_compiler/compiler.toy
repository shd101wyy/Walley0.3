;; compiler.toy
;; compiler written in toy language

;; define opcodes
(def SET 0x0)
(def GET 0x1)

(def CONST 0x2)
(def CONST_INTEGER 0x2100)
(def CONST_FLOAT 0x2200)
(def CONST_STRING 0x2300)
(def CONST_NULL 0x2400)

(def MAKELAMBDA 0x3)
(def RETURN 0x4)
(def NEWFRAME 0x5)
(def PUSH_ARG 0x6)
(def CALL 0x7)
(def JMP 0x8)
(def TEST 0x9)


;; GLOBAL VARIABLES
;; used to save variable name
;; this might be changed in the future
(def VARIABLE_TABLE  
  #[
    ;; frame 0
    #["cons", "car", "cdr", "vector", "vector-ref", "vector-set!",
      "vector-length", "vector?", "+", "-", "*", "/", "=",
      "<", ">", "<=", ">=", "eq?", "string?", "int?",
      "float?", "pair?", "null?", 
      "string<?", "string=?", "string-ref", "string-slice", "string-length",
      "vector-slice", "acos", "acosh", "asin", "asinh", "atan", "atanh",
      "ceil", "cos", "cosh", "exp", "floor", "loge", "pow", "sin", "sinh",
      "tan", "tanh", "display-string", "->int", "->float", "int->string", "float->string",
      "string-append", "lambda?", "vector-push!", "vector-pop!", "object", "object?", "object-keys",
      "bitwise-and", "bitwise-or", "bitwise-<<", "bitwise->>", "bitwise-not", "bitwise-xor", 
      "string->char-code", "char-code->string", "int->string-16", "string->int", "string->float"
      ]
    ])
;; used to save macros
(def MACROS #[#[]]) 
(def BUILTIN_PRIMITIVE_PROCEDURE_NUM (vector-length (vector-ref VARIABLE_TABLE 0)))

;; var ENVIRONMENT is written in C/JavaScript Language

;; find variable in Variable Table
(def (vt-find vt var-name)
  (def vt-length (vector-length vt))
  (defn vt-find-iter [i]
    (if (= i vt-length)
      #[-1, -1]
      (let [index (vector-find (vector-ref vt i)
                               var-name)]
        (if (= -1 index)
          (vt-find-iter (+ i 1))
          #[i, index])
        )))
  (vt-find-iter 0)) 

;; 4-digits-hex
(def (4-digits-hex num)
  (def s (int->string-16 num))
  (def l (string-length s))
  (def (zeros-ahead-str num s)
    (if (= num 0)
      s
      (zeros-ahead-str (- num 1)
                       (string-append s "0"))))
  (cond [(< l 4) ;; put 0 ahead
         (string-append (zeros-ahead-str (- 4 l) "")
                        s)]
        [else 
         s]))
;; printInstructions
(def (printInstructions insts)
  (def num 1)
  (def out-str "")
  (def insts-length (vector-length insts))
  (def (% n0 n1) (let! [result (->int (/ n0 n1))]  (- n0 (* result n1))))
  (def (helper i) ;; so ugly...
    (if (= i insts-length)
      (display out-str) ;; done
      (begin (set! out-str (string-append out-str
                                          (4-digits-hex (vector-ref insts i))
                                          " "))
             (if (= (% num 4)
                    0)
               (begin (display out-str)
                      (set! out-str "")
                      (++ num)
                      (helper (+ i 1)))
               (begin (++ num)
                      (helper (+ i 1)))))
      ))
  (helper 0))

;; check string is Integer
(def (isInteger n)
  (def l (string-length n))
  (if (= l 0)
    '()
    (begin (set! n (if (string=? (string-ref n 0)
                                 "-")
                     (string-slice 1 l)
                     n))
           (or (string=? n "0")     ;; 0
               (string-is-digit n)) ;; hexa or decimal 
           )
    ))
;; check string is float
(def (isFloat n)
  (def index-of-dot (string-find n "."))
  (if (= index-of-dot -1)
    '()  ;; not float
    (let! [a (string-slice n 
                           0
                           index-of-dot)
           b (string-slice n
                           (+ index-of-dot 1)
                           (string-length n))]
          (and (isInteger a)
               (isInteger b)))))
;; Compiler 
(def (compiler 
      l       ;;; input expression 
      vt      ;;; variable table
      insts   ;;; instructions
      macros  ;;; macros 
      lambdas ;;; lambdas
      tail-call-flag  ;;; used to check whether exp is tail call
      parent-func-name  ;;; current function name
      )
  (cond [(null? l) ;; null
         (vector-push! insts CONST_NULL)] ;; push null
        [(string? l) ;; num var .. null
         ;; check number
         (cond [(isInteger l) ;; integer
                (def i (string->int l))
                (if (< i 0) ;; negative number
                  (compiler (list "-" "0" l)
                            vt
                            insts
                            macros
                            lambdas
                            tail-call-flag
                            parent-func-name)
                  (begin ;(display i)
                         (if (> i 0x7FFFFFFF)
                           (begin ;(display 0xFFFFFFFF) 
                                  (display "ERROR: Integer too big")
                                  'ERROR)
                           (begin (vector-push! insts CONST_INTEGER) ;;;; TRY 32bits first
                                  (vector-push! insts (bitwise->> (bitwise-and 0xFFFF0000
                                                                               i)
                                                                  16))
                                  (vector-push! insts (bitwise-and 0xFFFF
                                                                   i))))
                         ))
                ]
               [(isFloat l)   ;; float
                (def f (string->float l))
                (if (< f 0) ;; negative number
                  (compiler (list "-" 0 l)
                            vt
                            insts
                            macros
                            lambdas
                            tail-call-flag
                            parent-func-name)
                  (begin 
                   (def i (->int f))   ;; positive number 
                   (if (> i 0xFFFF)
                     (begin (display "ERROR: Float too big")
                            'ERROR)
                     (begin (vector-push! insts CONST_FLOAT)
                            (vector-push! insts i) ;; int part
                            
                            (def d (->int (* (- f i) ;; decimal part
                                             10000)))
                            (vector-push! insts d)))
                   ))
                ]
               [(string=? (string-ref l 0) ;; string
                          "\"")
                (def s (eval-string-for-compilation l))
                (def length (string-length s))
                (vector-push! insts CONST_STRING) ;; create string
                (vector-push! insts (+ length 1)) ;; with length
                (def find-end false)
                (def (compile-string i) ;; return find-end
                  (if (= i length)
                    '() ;; didnt find end
                    (if (= (+ i 1)
                           length)
                      (begin ;; find end 
                       (vector-push! insts (bitwise-and (bitwise-<< (string->char-code s i)
                                                                    8)
                                                        0xFF00)
                                     'true))
                      (begin ;; didnt find end 
                       (vector-push! insts (bitwise-or (bitwise-<< (string->char-code s i)
                                                                   8)
                                                       (string->char-code s (+ i 1))))
                       (compile-string  (+ i 2))))))
                (if (compile-string 0)
                  '() ;; find end already
                  (vector-push! insts 0x0000 ;; add end
                                ))]
               [else          ;; variable
                (def index (vt-find vt l))
                (if (= (vector-ref index 0)
                       -1)
                  (begin ;; didnt find 
                   (display (string-append "ERROR: undefined variables: " l))
                   'ERROR ;; error handler
                   )
                  (begin ;; find 
                   (vector-push! insts (bitwise-or (bitwise-<< GET 12)
                                                   (vector-ref index 0)))
                   (vector-push! insts (vector-ref index 1))))
                ])]
        [(pair? l)
         (def tag (car l))
         (cond [(int? tag) '()]        ;; macro get 
               [(string=? tag "quote") ;; quote
                (def v (cadr l))
                (cond [(pair? v)
                       (def (quote-list l)  ;; function used to compile list
                         (cond [(null? l)
                                '()]
                               [(pair? (car l)) ;; (() a) car is pair
                                (list "cons" (quote-list (car l)) (quote-list (cdr l)))]
                               [(eq? (car l) ".")
                                (list "quote" (cadr l))]
                               ;; (cons "quote" (cons (cadr l) '()))]
                               [else 
                                (list "cons" 
                                      (list "quote" (car l))
                                      (quote-list (cdr l)))]))
                       (compiler (quote-list v) ;; compile formatted expression
                                 vt
                                 insts
                                 macros
                                 lambdas
                                 tail-call-flag
                                 parent-func-name)] 
                      [(or (null? v)
                           (isInteger v)
                           (isFloat v)
                           (string=? (string-ref v 0)
                                     "\""))
                       ;; it is () int float or string. 
                       (compiler v
                                 vt
                                 insts
                                 macros
                                 lambdas
                                 tail-call-flag
                                 parent-func-name)]
                      [else   ;; symbol/string 
                       (compiler (string-append "\"" v "\"")
                                 vt
                                 insts
                                 macros
                                 lambdas
                                 tail-call-flag
                                 parent-func-name)]
                      )
                ]
               [(string=? tag "quasiquote")  ;; quasiquote
                (def v (cadr l))
                (cond [(pair? v)
                       (def (quasiquote l)
                         (cond [(null? l) '()] 
                               [(pair? (car l))
                                (cond [(eq? (caar l)
                                            "unquote")
                                       (list "cons" (cadr (car l)) (quasiquote (cdr l)))]
                                      [(eq? (caar l)
                                            "unquote-splice")
                                       (list "append" (cadr (car l)) (quasiquote (cdr l)))]
                                      [else 
                                       (list "cons" (quasiquote (car l)) (quasiquote (cdr l)))])
                                ]
                               [(eq? (car l) ".")
                                (list "quote" (cadr l))]
                               [else 
                                (list "cons"
                                      (list "quote" (car l))
                                      (quasiquote (cdr l)))]
                               ))

                       (compiler (quasiquote v)
                                 vt
                                 insts
                                 macros
                                 lambdas
                                 tail-call-flag
                                 parent-func-name)]
                      [(or (null? v)
                           (isInteger v)
                           (isFloat v)
                           (string=? (string-ref v 0)
                                     "\""))
                       ;; it is () int float or string. 
                       (compiler v
                                 vt
                                 insts
                                 macros
                                 lambdas
                                 tail-call-flag
                                 parent-func-name)]
                      [else   ;; symbol/string 
                       (compiler (string-append "\"" v "\"")
                                 vt
                                 insts
                                 macros
                                 lambdas
                                 tail-call-flag
                                 parent-func-name)])
                ]
               [(string=? tag "def")
                (def variable-name (cadr l))
                (if (pair? variable-name)
                  ;; (def (add a b) (+ a b))
                  (let! [var-name (car variable-name)
                         args     (cdr variable-name)
                         lambda-body (cons "lambda" (cons args (cddr l)))]
                        (compiler (list "def" var-name lambda-body)
                                  vt
                                  insts
                                  macros
                                  lambdas
                                  tail-call-flag
                                  parent-func-name))
                  ;; (def variable-name variable-value)
                  (begin (def variable-value (if (null? (cddr l)) '() (caddr l))) 
                         ;; check whether variable already defined
                         (def frame (vector-ref vt 
                                                (- (vector-length vt)
                                                   1)))
                         (def frame-length (vector-length frame))
                         (def (check-variable-existed-in-current-top-frame i)
                           (if (= i frame-length)
                             (begin (vector-push! frame variable-name)
                                    frame-length)  ;; didn't find, so add to top frame
                             (if (string=? (vector-ref frame i)
                                           variable-name)
                               ;; find variable-name
                               i
                               ;; didn't find, so continue
                               (check-variable-existed-in-current-top-frame (+ i 1)))))
                          (def variable-index (check-variable-existed-in-current-top-frame 0)) ;; search variable
                          (set! parent-func-name  ;; update parent-func-name if val is lambda
                                (if (and (pair? variable-value)
                                         (eq? "lambda" (car variable-value)))
                                  variable-name
                                  parent-func-name))
                          (compiler variable-value  ;; compile value
                                    vt
                                    insts
                                    macros
                                    lambdas
                                    tail-call-flag
                                    parent-func-name)
                          ;; add instructions
                          (vector-push! insts (bitwise-or (bitwise-<< SET 12)
                                                          (- (vector-length vt)
                                                             1)))
                          (vector-push! insts variable-index)
                         ))]
               [(string=? tag "set!")
                '()]
               [(string=? tag "if")
                '()]
               [(string=? tag "begin")
                '()]
               [(string=? tag "lambda")
                '()]
               [(string=? tag "defmacro")
                '()]
               [(string=? tag "macroexpand-1")
                '()]
               [(string=? tag "return")
                '()]
               [else
                (display "ERROR: compiler error")
                'ERROR] ;; error handler
               )]
        [else
         (display "ERROR: compiler error")
         (display l)
         'ERROR ;; error handler
         ])
  )
;; Compiler Begin
(def (compiler-begin
      l       ;;; input expression
      vt      ;;; variable table
      insts   ;;; instructions
      macros  ;;; macros 
      lambdas ;;; lambdas 
      tail-call-flag ;;; used to check whether exp is tail call
      parent-func-name  ;;; current function name
      )
  (if (null? l)
    'Done   ; finish compilation
    (if (and (null? (cdr l)) ;; last exp
             (pair? (car l)) ;; exp might be lambda
             (string=? (car (car l))  ;; has the same function name
                       parent-func-name)) 
      ;; tail call
      (begin (let! [result (compiler (car l)
                                     vt
                                     insts
                                     macros
                                     lambdas
                                     'true     ;; tail call
                                     '())]
                   (if (eq? result 'ERROR)
                     (begin (display "EXP: ") (display (car l))) ;; get error
                     '()))
             'Done) ;; finish compilation
      ;; not tail call
      (begin (let [result (compiler (car l)
                                    vt
                                    insts
                                    macros
                                    lambdas
                                    '()        ;; not tail call
                                    parent-func-name)]
               (if (eq? result 'ERROR)
                 (begin (display "EXP: ")
                        (display (car l))) ;; get error
                 '())
               (compiler-begin (cdr l)
                               vt
                               insts))
             ))))


;; test
;; run compiler
(def x "(def x 12) (def y 15) (def x 13)")
(def l (lexer x))
(def p (parser l))

(display "PARSER: ")
(display p)

(def INSTS #[])
(compiler-begin  p 
          VARIABLE_TABLE
          INSTS)
(printInstructions INSTS)
