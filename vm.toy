;; this function is for ~@ 
(def (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))
;; defm
;; for defining single macro
(defmacro defm ([macro_name a b] [defmacro ~macro_name (~a ~b)]))
;; list
(def (list . arg) arg)
;; while
(defm while [arg . body]
  (let [__t (lambda [] (if ~arg (begin ~@body (__t))  () ))]
    (__t)))
;; check variable type
;; this function has problem
;; because n:type has to be lambda first
(def (typeof n)
     (cond [(int? n)
	    'int]
	   [(float? n)
	    'float]
	   [(string? n)
	    'string]
	   [(lambda? n)
	    'lambda]
	   [(vector? n)
	    'vector]
	   [else (n:type)]))
;;(def n 0)
;;(while (< n 10) (display-string n) (set! n (+ n 1)))

;; defs
;; (defs a 12 b 15) => (begin (def a 12) (def b 15))
(defmacro defs 
  [() ()]
  [(a b) (def ~a ~b)]
  [(a b . arg) (begin (def ~a ~b) (defs ~@arg))]
  )
;; (let [a 12 b 15] (+ a b)) => ((lambda [] (def a 12) (def b 15) (+ a b)))
(defm let [var_vals . body]
  ((lambda [] (defs ~@var_vals) (begin ~@body))))

;; and
(defmacro and 
  [() 'true]
  [(a) (if  ~a  ~a ())]
  [(a . b) (if ~a  (and ~@b) ())])
;; or
(defmacro or 
	[() ()] 
	[(a) (if ~a ~a ())] 
	[(a . b) (if ~a ~a (or ~@b))])
;; string-append
(defmacro string-append
  [() ""]
  [(a) ~a]
  [(a . b) (string-append ~a (string-append ~@b))])
;; >
(defmacro > 
  [(a b) (> ~a ~b)]
  [(a . b) (> ~a (> ~@b))])
;; <
(defmacro <
  [(a b) (< ~a ~b)]
  [(a . b) (< ~a (< ~@b))])
;; <=
(defmacro <=
  [(a b) (<= ~a ~b)]
  [(a . b) (<= ~a (<= ~@b))])
;; >=
(defmacro <=
  [(a b) (<= ~a ~b)]
  [(a . b) (<= ~a (<= ~@b))])
;; =
(defmacro =
  [(a b) (= ~a ~b)]
  [(a . b) (= ~a (= ~@b))])
;; eq?
(defmacro eq?
  [(a b) (eq? ~a ~b)]
  [(a . b) (eq? ~a (eq? ~@b))])

;; macros used to extend + - * /
(defmacro +
  [() 0]
  [(a) ~a]
  [(a . b) (+ ~a (+ ~@b))])

(defmacro -
  [(a) (- 0 ~a)]
  [(a . b) (- ~a (+ ~@b))])

(defmacro * 
  [() 1]
  [(a) ~a]
  [(a . b) (* ~a (* ~@b))])

(defmacro / 
  [(a) (/ 1 a)]
  [(a . b) (/ ~a (* ~@b))])


;; avl tree
(def (make-avl-tree)
     ;; getter
     (defm key [node] [vector-ref ~node 0])
     (defm value [node] [vector-ref ~node 1])
     (defm left [node] [vector-ref ~node 2])
     (defm right [node] [vector-ref ~node 3])
     (defm height [node] [if (null? ~node) -1 (vector-ref ~node 4)])
     (defm parent [node] [vector-ref ~node 5])
 
     ;; setter
     (defm set-parent [node v] (if (null? ~node) 'done (vector-set! ~node 5 ~v)))
     (defm set-left [node v] (begin (vector-set! ~node 2 ~v) (set-parent ~v ~node)))
     (defm set-right [node v] (begin (vector-set! ~node 3 ~v) (set-parent ~v ~node)) )
     (defm set-key [node v] [vector-set ~node 0 ~v])
     (defm set-value [node v] [vector-set! ~node 1 ~v])
     (defm set-height [node v] [vector-set! ~node 4 ~v])
     
     ;; true false
     (def #t 1)
     (def #f ())
     ;; get max
     (def (max a0 a1) (if >= a0 a1) a0 a1)
     ;; make node
     (def (make-node key value left right parent)
     	  (vector key value left right (+ 1 (max (height left) (height right)))  parent))
     ;; make root
     (def (make-root key value) (vector key value '() '() 0 '()))
     
     ;; create root
     (def root '())
     
     ;; find value by key
     (def (find_ node k)
	  (if (null? node)
	      '() ;; didn't find
	      (let [node-key (key node)]
		(if (string=? node-key k)
		    (value node)
		    (if (string<? k node-key)
			(find_ (left node) ;; < so find left
			       k)
			(find_ (right node) ;; > so find right
			       k))))))
     ;; find according to key
     (def (find k)
          (find_ root k))
     
     ;; rotate left
     (def (rotate-left node)
	  (let [temp node
		node2 (right node)]
	    (if (null? (parent temp)) ;; try to rotate root
		(begin (set! root node2) ;; update root
		       (set-parent root '())
		       (set-right temp (left node2))
		       (set-left node2 temp)
		       ) 
		;; parent is not root
		(begin (set-right (parent node) node2) 
		       (set-right temp (left node2))
		       (set-left node2 temp)))
	    ;; parent set child
	    ;;(set-right (parent temp) node2)
	    ;; update height
	    (set-height temp (+ 1 (max (height (left temp)) (height (right temp)))))
	    (set-height node2 (+ 1 (max (height (left node2)) (height (right node2)))))
	    ))
     ;; rotate right
     (def (rotate-right node)
	  (let [temp node
		node2 (left node)]
	    (if (null? (parent temp)) ;; try to rotate root
		(begin (set! root node2) ;; update root
		       (set-parent root '())
		       (set-left temp (right node2))
		       (set-right node2 temp)
		       ) 
		;; parent is not root
		(begin (set-left (parent node) node2) 
		       (set-left temp (right node2))
		       (set-right node2 temp)))
	    ;; parent set child
	    ;;(set-left (parent temp) node2)
	    ;; update height
	    (set-height temp (+ 1 (max (height (left temp)) (height (right temp)))))
	    (set-height node2 (+ 1 (max (height (left node2)) (height (right node2)))))
	    ))
     ;; rotate rightLeft
     (def (rotate-right-left node)
       (rotate-right (right node))
       (rotate-left node))
     ;; rotate leftRight
     (def (rotate-left-right node)
       (rotate-left (left node))
       (rotate-right node))
     ;; balance node
     (def (balance node)
       (let [balance# (- (height (left node))
			  (height (right node)))]
	 (cond [(= balance# 2) ;; adjust left side
		(if (= 1 
		       (- (height (left (left node)))
			  (height (right (left node)))))
		    (rotate-right node)
		    (rotate-left-right node)
		    )]
	       [(= balance# -2) ;; adjust right side
		(if (= -1
		       (- (height (left (right node)))
			  (height (right (right node)))))
		    (rotate-left node)
		    (rotate-right-left node)
		    )]
	       [else ;; no need to adjust 
		'()])
	 ))
     ;; insert

     (def (insert_ node k value parent left?)
	  ;;(display-string (null? node))
	  (if (null? root) ;; root doesn't exist
	      (set! root (make-root k value)) ;; set root	
	      (if (null? node) ;; node doesn't exist
		  (if left? 
		      (set-left  parent (make-node k value '() '() parent)) ;; set left
		      (set-right parent (make-node k value '() '() parent))) ;; set right
		  (if (string=? k (key node))
		      ;; same
		      (set-value node value)
		      ;; not same
		      (begin (if (string<? k (key node))
				 (begin ;; left  
				   (insert_ (left node)
					    k
					    value
					    node
					    #t)
				   (balance node))
				 (begin ;; right 
				   ;;(display-string 'RIGHT)
				   (insert_ (right node)
					    k
					    value
					    node
					    #f)
				   (balance node)))  
			     ;; update height
			     (set-height node (+ 1 (max (height (left node)) (height (right node)))))
			     )
		      )
		  ))) 
     (def (insert key value)
	  (insert_ root key value '() #t))
     
     (def (find-biggest-on-left-side node)
	  (if (null? (right node))
	      node
	      (find-biggest-on-left-side (right node))))
     ;; remove     
     (def (remove_ k node)
	  (if (null? node)
	      '() ;; didn't remove, key doesnt exist
	      (if (eq? (key node) k)
		  ;; find
		  (let [null-left? (null? (left node))
				   null-right? (null? (right node))]
		    (cond [(and null-left? null-right?) ;; empty
			(if (null? (parent node))
			    (set! root '()) ;; reset root
			    (if (eq? (left (parent node)) node)
				(set-left (parent node) '()) ;; delete this node, left
				(set-right (parent node) '())))] ;; right 
			  ;; has one child on the left side
			  [null-right? 
			(if (null? (parent node))
			    ;; update root
			    (begin (set! root (left node))
				   (set-parent root '()))
			    (if (eq? (left (parent node)) node)
				(set-left (parent node) (left node))
				(set-right (parent node) (left node)))
			    )
			]
		       ;; has one child on the right side
			  [null-left? 
			   (if (null? (parent node))
			    ;; update root
			       (begin (set! root (right node))
				      (set-parent root '()))
			       (if (eq? (left (parent node)) node)
				   (set-left (parent node) (right node))
				   (set-right (parent node) (right node)))
			       )]
			  [else ;; has two child.    this part unfinished
			   (let [y (find-biggest-on-left-side (left node))]
			     (set-left y (left node)) ;; set children
			     (set-right y (right node)) ;; set children
			     (set-parent y (parent node)) ;; set parent
			     (if (null? (parent node))
				 ;; reset root
				 (set! root y)
				 ;; it's not root
				 (if (eq? node (left (parent node)))
				     [begin  ;; node is left child of parent
				       (set-left (parent node)
						 y)
				       (balance y)]
				     [begin  ;; node is right child of parent
				       (set-right (parent node)
						  y)
				       (balance y)]))
			     )]))
		  ;; unfound
		  (if (string<? k (key node))
		      (remove_ k (left node))  ;; search left
		      (remove_ k (right node)));; search right
		  ))
	  )
     (def (remove k) (remove_ k root))
     
     ;; return value
     (lambda [msg arg] 
       (cond [(string=? msg 'remove)            ;; remove key
	      (lambda [arg] (remove arg))]
	     [(string=? msg 'builtin-properties) ;; get builtin-properties
	      '(remove builtin-properties)]
	     [(null? arg)                       ;; ref key
	      (find msg)]
	     [else (insert msg arg)]            ;; set value
	;;[(string=? msg 'root) root]
	;;[(string=? msg 'get)      ;; get    
	;; (lambda [key] (find key))]
	;;[(string=? msg 'set)      ;; set
	;; (lambda [key value] (insert key value))]
	;;[(string=? msg 'remove)   ;; remove
	;; (lambda [key] (remove key))]
	;;[else 'ERROR])
	))
     )

;; create dictionary
;; using avl tree
(def (dictionary . arg)
     (def output (make-avl-tree))
     (def (dict-iter arg)
	  (if (null? arg)
	      output
	      (begin (output (car arg) (car (cdr arg)))
		     (dict-iter (cdr (cdr arg))))))
     (dict-iter arg))

;; save space for ->string
(def list->string ())
(def vector->string ())
(def lambda->string ())
(def dictionary->string ())
;; lambda->string
(def (lambda->string a)
     "<lambda>")
;; int->string   builtin
;; float->string buitlin
;; vector to string
(def (vector->string v)
     (def (vector-string-iter v count output-str)
	  (if (= count (vector-length v))
	      (string-append output-str "]")
	      (let [a (vector-ref v count)]
		(cond [(int? a) 
		       (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") (int->string a)))]
		      [(float? a)
		       (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") (float->string a)))]
		      [(vector? a)
		       (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") (vector->string a)))]
		      [(string? a)
		       (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") a))]
		      [(pair? a)
		      (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") (list->string a)))]
		      [(lambda? a)
		       (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") (lambda->string a)))]
		      ;;[(? a)
		      ;; (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") (lambda->string a)))]		     
		      [else 
		       (vector-string-iter v (+ count 1) (string-append output-str (if (= count 0) "" " ") (a:->string)))]
		    ))))
     (vector-string-iter v 0 "#["))

;; lexer has problem
;; so here stackoverflow
;; need to change vm.js
;; list->string
;(def (list->string v)
;     (def (list->string-iter v output-str)
;	  (if (null? v) (string-append output-str ")")
;	    (let [a (car v)]
;		 (cond [ (int? a)
;		         (list->string-iter (cdr v) (string-append output-str (int->string a) (if (null? (cdr v)) "" " ")))]
;		       [ (float? a)
;			 (list->string-iter (cdr v) (string-append output-str (float->string a) (if (null? (cdr v)) "" " ")))]
;		       [ (vector? a)
;			 (list->string-iter (cdr v) (string-append output-str (vector->string a) (if (null? (cdr v)) "" " ")))]
;		       [ (string? a)
;			 (list->string-iter (cdr v) (string-append output-str a (if (null? (cdr v)) "" " ")))]
;		       [ (pair? a)
;			 (list->string-iter (cdr v) (string-append output-str (list->string a) (if (null? (cdr v)) "" " ")))]
;		       [(lambda? a)
;			(list->string-iter (cdr v) (string-append output-str (lambda->string a) (if (null? (cdr v)) "" " ")))]
;		       [else 
;			(list->string-iter (cdr v) (string-append output-str (a:->string) (if (null? (cdr v)) "" " ")))]
;		       ))))
;    (list->string-iter v "("))
;; (str 12 "Hello" " world") => "12Hello world"
;(def (->str arg)
;     (cond [(int? arg) (int->string arg)]
;	   [(float? arg) (float->string arg)]
;	   [(vector? arg) (vector->string arg)]
;	   [(string? arg) arg]
;	   [(pair? arg) (list->string arg)]
;	   [(lambda? arg) (lambda->string arg)]
;	   [else (arg:->string)]))
;(defmacro str 
;  [() ""]
;  [(a) (->str ~a)]
;  [(a . b) (string-append (->str ~a) (str ~@b))])

   

;; library that add ratio support
 (def (install-ratio-library)
     ;; backup + - * /
     (def o_+ +)
     (def o_- -)
     (def o_* *)
     (def o_/ /)
     (def o_= =)
     (def o_< <)
     (def o_> >)
     (def o_<= <=)
     (def o_>= >=)
     (def o_->float ->float)
     ;; %
     (def (% n0 n1) (let [result (->int (o_/ n0 n1))]  (o_- n0 (o_* result n1))))
     
     ;; ratio math library
     (def (gcd a b)
	  (def (gcd-iter a b)
	       (if (o_= b 0) a (gcd-iter b (% a b))))
	  (if (o_= b 1) 1 (gcd-iter a b))
	  ;;(if (o_= b 0)
	  ;;    a
	  ;;    (gcd b (% a b)))
	  )
     ;; create ratio
     (def (make-ratio numer denom)
	  (def g (gcd numer denom))
	  (def n (o_/ numer g))
	  (def d (o_/ denom g))
	  (if (= d 1) 
	      n ;; return int
	      {'n n 
	       'd d 
	       'type 'ratio 
	       '->string (lambda [] (string-append (int->string n) "/" (int->string d)))}
	      ))
     ;; ->float also support change ratio to string
     (set! ->float (lambda [n] (if (or (int? n) (float? n))
     							(o_->float n)
     							(o_->float (o_/ n:n n:d)))))
     ;; get denominator
     (def (denom n)
	  (if (int? n) 1  (if (float? n) 1 n:d)))
     ;; get numerator
     (def (numer n)
	  (if (int? n) n (if (float? n) n n:n)))
     ;; fraction arithematic
     (def (add-rat x y)
	  (make-ratio (o_+ (o_* (numer x) (denom y))
			   (o_* (numer y) (denom x)))
		      (o_* (denom x) (denom y))))
     (def (sub-rat x y)
	  (make-ratio (o_- (o_* (numer x) (denom y))
			   (o_* (numer y) (denom x)))
		      (o_* (denom x) (denom y))))
     (def (mul-rat x y)
	  (make-ratio (o_* (numer x) (numer y))
		      (o_* (denom x) (denom y))))
     (def (div-rat x y)
	  (make-ratio (o_* (numer x) (denom y))
		      (o_* (denom x) (numer y))))
     (set! + (lambda [a b]
	       (if (or (float? a) (float? b)) ;; a or b is float
		   (o_+ (o_/ (numer a) (denom a))
			(o_/ (numer b) (denom b)))
		   (add-rat a b))))
     (set! - (lambda [a b]
	       (if (or (float? a) (float? b)) ;; a or b is float
		   (o_- (o_/ (numer a) (denom a))
			(o_/ (numer b) (denom b)))
		   (sub-rat a b))))
     (set! * (lambda [a b]
	       (if (or (float? a) (float? b)) ;; a or b is float
		   (o_* (o_/ (numer a) (denom a))
			(o_/ (numer b) (denom b)))
		   (mul-rat a b))))
     (set! / (lambda [a b]
	       (if (or (float? a) (float? b)) ;; a or b is float
		   (o_/ (o_/ (numer a) (denom a))
			(o_/ (numer b) (denom b)))
		   (div-rat a b))))
     (set! = (lambda [a b]
	       (o_= (->float a) (->float b))))
     (set! > (lambda [a b]
	       (o_> (->float a) (->float b))))
     (set! < (lambda [a b]
	       (o_< (->float a) (->float b))))
     (set! >= (lambda [a b]
	       (o_>= (->float a) (->float b))))
     (set! <= (lambda [a b]
	       (o_<= (->float a) (->float b))))
     )


;;(def test {'a 12 'b 15 'add (lambda [a b] (+ a b))})
;;test:b
;;(test:add test:a test:b)
;;(install-ratio-library)
;(vector->string #(1 2 3 3.4 (lambda [a b] a)))
;;(def x (/ 3 12))
;(x:->string)
;(def (factorial n)  (if (= n 0) 1 (* n (factorial (- n 1)))))
;(def (factorial n result)  (if (= n 0) result (factorial (- n 1) (* result n))))
;;(def x (/ 3 4))
;;(->float x)
;;(or 3 4 5)




(and 3 4 5 6)
































