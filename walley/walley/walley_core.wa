;; walley_core.wa 
;; walley language 
;; created by Yiyi Wang 
;; Copyright (c) Yiyi Wang. All rights reserved.
(def walley-core-author 'Yiyi-Wang)
(def walley-core-version "0.0016")
(def walley-language-version "0.3.8459")


;; check data type
(def int? (lambda [v] (eq? (typeof v) 'integer)))
(def integer? int?)
(def float? (lambda [v] (eq? (typeof v) 'float)))
(def pair? (lambda [v] (eq? (typeof v) 'pair)))
(def list? pair?)
;(defn ratio? [v] (eq? (typeof v) 'ratio))
(def null? (lambda [v] (eq? v ())))
(def vector? (lambda [v] (eq? (typeof v) 'vector)))
(def lambda? (lambda [v] (eq? (typeof v) 'lambda)))
(def table? (lambda [v] (eq? (typeof v) 'table)))
(def string? (lambda [v] (eq? (typeof v) 'string)))

;; append and reverse functions.
;; which will be used for macro expansion
(def append 
     (lambda (a b)
       (if (null? a)
	   b
	 (cons (car a)
	       (append (cdr a)
		       b)))))
;; reverse the list
(def reverse 
     (def reverse_iter 
     	  (lambda (a result)
	  	  (if (null? a)
                    result
                    (reverse_iter (cdr a)
                                  (cons (car a)
                                        result)))))
     (reverse_iter a ()))

;; get the length of the list
(def list-length
  (lambda [n]
          (def list-length-iter
            (lambda [n r]
                    (if (null? n)
                      r
                      (list-length-iter (cdr n)
                                        (+ r 1)))))
          (list-length-iter n 0)))

(def error (lambda [s] (display "ERROR: ") (display s)))

;; defn macro
;; like clojure
;; (defn func-name args . body)
(defmacro defn
  [(func_name args . body)
  `(def ~func_name (lambda ~args ~@body))
  ]
  )


;; list macro
(defmacro list 
  [() ()]
  [(a) `(cons ~a ())]
  [(a . b) `(cons ~a (list ~@b))])

;; cond macro
(defmacro cond 
  [() ()]
  [(#else body)
   body]
  [(#else body . rest)
   (display "ERROR: cond invalid statements.\n")]
  [(test body)
  `(if ~test ~body '())]
  [(test body . rest)
   `(if ~test ~body (cond ~@rest))])

;; and
(defmacro and 
  [() 'true]
  [(a) a]
  [(a . b) `(if ~a (and ~@b) ())]
  )	 

;; or
(defmacro or
  [() ()]
  [(a) a]
  [(a . b) `(if ~a ~a (or ~@b))]
  )
	  
;; test cond
;(display (cond (= 0 1) (display "Hi1")
;               (= 2 3) (display "Hi2")
;               else    (display "else")
;               1
;               ))

(defmacro defm 
	  [(macro-name args pattern)
	   `(defmacro ~macro-name (~args ~pattern))])


;; str
;; eg (str "Hello " "World") -> "Hello World"
(defn str [. b]
  (defn str-iter [b]
    (if (null? b)
    ""
    (string-append (car b)
                   (str-iter (cdr b)))))
  (str-iter b))


;; get length of several data types
(defn len [b] 
  (if (null? b)
    0
    (if (string? b)
      (string-length b)
      (if (pair? b)
        (list-length b)
        (if (vector? b)
          (vector-length b)
          (error "Function len invalid data type"))))))


;; string=?
;; string>?
;; string<?
;; string>=?
;; string<=?

(defn string=? [a b] (= (strcmp a b) 0))
(defn string>? [a b] (> (strcmp a b) 0))
(defn string<? [a b] (< (strcmp a b) 0))
(defn string>=? [a b] (>= (strcmp a b) 0))
(defn string<=? [a b] (<= (strcmp a b) 0))

;; **
(def ** math-pow)

;; ########################### LIST ############################
;; some functions for list

(defn caar [x] (car (car x)))
(defn cadr [x] (car (cdr x)))
(defn cddr [x] (cdr (cdr x)))
(defn caddr [x] (car (cdr (cdr x))))
(defn cdddr [x] (cdr (cdr (cdr x))))
(defn cadddr [x] (car (cdr (cdr (cdr x)))))

(def list-reverse reverse)
(defn list-ref [l i]
  (if (= i 0)
    (car l)
    (list-ref (cdr l)
              (- i 1))))

;; list-append
;; eg (list-append '(1 2) '(4 5)) => '(1 2 4 5)
;; eg (list-append '(1 2) 4) => '(1 2 4)
(defn list-append [l0 l1]
  (defn list-append-iter0 [l0]
    (if (null? l0)
      l1
      (cons (car l0) 
            (list-append-iter0 (cdr l0)))))
  (if (pair? l1)
    (list-append-iter0 l0)
    (begin (set! l1 (cons l1 '()))
           (list-append-iter0 l0))))
;; list->vector
(defn list->vector [l]
  (defn list->vector-iter [l output]
    (if (null? l)
      output
      (list->vector-iter (cdr l) 
                         (vector-push! output (car l)))))
  (list->vector-iter l #[]))


;; ############## VECTOR ########################
;; vector->list
(defn vector->list [v]
  (def length (vector-length v))
  (defn vector->list-iter [v i]
    (if (= i length)
      '()
      (cons v[i]
            (vector->list-iter v
                               (+ i 1)))))
  (vector->list-iter v 0))

;; vector-find
;; find element in vector and return its index
(defn vector-find [v o start-index]
  (set! start-index (or start-index 0))
  (def length (vector-length v))
  (defn vector-find-iter [i]
    (if (= i length)
      -1 ;; didn't find
      (if (eq? v[i]
               o)
        i
        (vector-find-iter (+ i 1))))) 
  (vector-find-iter start-index))





