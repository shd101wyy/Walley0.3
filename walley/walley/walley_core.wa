;; walley_core.wa 
;; walley language 
;; created by Yiyi Wang 
;; Copyright (c) Yiyi Wang. All rights reserved.

;; append and reverse functions.
;; which will be used for macro expansion
(def append 
     (lambda (a b)
       (if (null? a)
	   b
	 (cons (car a)
	       (append (cdr a)
		       b)))))
;; reverse the list
(def reverse 
     (def reverse_iter 
     	  (lambda (a result)
	  	  (if (null? a)
                    result
                    (reverse_iter (cdr a)
                                  (cons (car a)
                                        result)))))
     (reverse_iter a ()))

;; get the length of the list
(def list-length
  (lambda [n]
          (def list-length-iter
            (lambda [n r]
                    (if (null? n)
                      r
                      (list-length-iter (cdr n)
                                        (+ r 1)))))
          (list-length-iter n 0)))

(def error (lambda [s] (display "ERROR: ") (display s)))

;; list macro
(defmacro list 
  [() ()]
  [(a) `(cons ~a ())]
  [(a . b) `(cons ~a (list ~@b))])

;; cond macro
(defmacro cond 
  [() ()]
  [(#else body)
   body]
  [(#else body . rest)
   (display "ERROR: cond invalid statements.\n")]
  [(test body)
  `(if ~test ~body ())]
  [(test body . rest)
   `(if ~test ~body (cond ~@rest))])

;; test cond
;(display (cond (= 0 1) (display "Hi1")
;               (= 2 3) (display "Hi2")
;               else    (display "else")
;               1
;               ))

(defmacro defn
  [(var_name args . body)
  `(def ~var_name (lambda ~args ~@body))
  ]
  )

(defmacro defm 
	  [(macro-name args pattern)
	   `(defmacro ~macro-name (~args ~pattern))])


;; logic > macro
(defm > [a b] `(< ~b ~a))
(defm >= [a b] `(<= ~b ~a))



;(display "TEST +\n")
;; + - * / lambda extension
;; where ! means doesn't replace to lambda
;; so (!+ ~@b) means still use macro
(defmacro +
  [() 0]
  [(a) a] 
  [(a b) `(+ ~a ~b)]
  [(a . b) `(+ ~a (!+ ~@b))])

(defmacro -
  [(a) `(- 0 ~a)]
  [(a . b) `(- ~a (+ ~@b))])

(defmacro * 
  [() 1]
  [(a) a]
  [(a . b) `(* ~a (!* ~@b))])

(defmacro / 
  [(a) `(/ 1 a)]
  [(a . b) `(/ ~a (* ~@b))])

;; str
;; eg (str "Hello " "World") -> "Hello World"
(defn str [. b]
  (defn str-iter [b]
    (if (null? b)
    ""
    (string-append (car b)
                   (str-iter (cdr b)))))
  (str-iter b))
(def list? pair?)

;; check data type
(defn int? [v] (eq? (typeof v) 'integer))
(def integer? int?)
;(defn float? [v] (eq? (typeof v) 'float))
;(defn ratio? [v] (eq? (typeof v) 'ratio))
;(defn null? [v] (eq? v ()))
(defn vector? [v] (eq? (typeof v) 'vector))
;(defn lambda? [v] (eq? (typeof v) 'lambda))
(defn table? [v] (eq? (typeof v) 'table))
(defn string? [v] (eq? (typeof v) 'string))

;; get length of several data types
(defn len [b] 
  (if (null? b)
    0
    (if (string? b)
      (string-length b)
      (if (pair? b)
        (list-length b)
        (if (vector? b)
          (vector-length b)
          (error "Function len invalid data type"))))))

